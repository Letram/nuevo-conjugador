@page "/TableReconocimientos"
@page "/TableReconocimientos/{verb}"

@using Services
@using ConexionConjugador
@using ConexionCorrector
@using ConexionLematizador
@using Data
@using Microsoft.AspNetCore.Html;
@using System.Globalization

@inject IStringLocalizer<TablaReconocimientos> _localizer
@inject AppState state

@implements IDisposable

@if (reconocimientos.Count > 0)
{
    <header id="verb_name">
        <h1 class="uk-text-center">
            @((MarkupString)string.Format(_localizer.WithCulture(state.getCurrentCulture())["conjugacion_verbo"].Value, reconocimientos[_selectedIndex].FormaCanonica))
        </h1>
        @if (notas.Count > 0)
        {
            <p class="uk-text-meta uk-text-center" id="same_conjugation">@((MarkupString)notas.First(nota => nota.IdNota >= 7002 && nota.IdNota <= 7173).Descripcion)</p>
        }
    </header>
    <hr />
    <div id="results" class="uk-child-width-expand uk-grid-column-medium" uk-grid>
        @foreach (Reconocimiento reconocimiento in reconocimientos)
        {
            int index = reconocimientos.IndexOf(reconocimiento);
            <div id="@index" class="uk-card uk-card-small uk-card-default @((_selectedIndex == index) ? "selected" : "")"
                 @onclick="e => GetDataFromSelectedIndex(index)">
                <p class="uk-text-center">
                    @string.Format(_localizer.WithCulture(state.getCurrentCulture())["verbo_seleccion"], searchText, reconocimiento.FormaCanonica)
                </p>
            </div>
        }
    </div>
    @*<table class="uk-table">
        <thead>
            <tr>
                @foreach (string header in reconocimientoHeaders)
                {
                    <th>@header</th>
                }
            </tr>
        </thead>
        <tbody>
            @foreach (Reconocimiento reconocimiento in reconocimientos)
            {
                <tr>
                    <td>@reconocimiento.FormaCanonica.</td>
                    <td>@reconocimiento.Frecuencia</td>
                    <td>@reconocimiento.IdFlexion</td>
                    <td>@reconocimiento.IdFormaCanonica</td>
                    <td>@reconocimiento.Prefijos</td>
                    <td>@reconocimiento.Pronombres</td>
                </tr>
            }
        </tbody>
    </table>
    <hr />
    <table class="uk-table">
        <thead>
            <tr>
                @foreach (string header in canonicaHeaders)
                {
                    <th>@header</th>
                }
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>@info.Antigua</td>
                <td>@info.DRAEXXIII</td>
                <td>@info.FormaCanonica</td>
                <td>@info.Frecuencia</td>
                <td>@info.IdCategoria</td>
                <td>@info.IdCategoriaGN</td>
                <td>@info.IdFlexion</td>
                <td>@info.MaxAcepciones</td>
                <td>@info.MaxEtimologia</td>
                <td>@info.NumAcepcion</td>
                <td>@info.NumAcepcionSec</td>
                <td>@info.NumEtimologia</td>
                <td>@info.PosAcepcion</td>
                <td>@info.PosAcepcionSec</td>
            </tr>
        </tbody>
    </table>*@
    <div class="uk-margin uk-card uk-card-default uk-card-body notes">
        <div class="uk-flex uk-flex-between card-heading">
            <h3 class="uk-card-title">
                @_localizer["notas"].Value
            </h3>
            <div>
                <button class="uk-button uk-button-text close-btn"
                        uk-toggle="target: #notes; animation: uk-animation-fade"
                        type="button"
                        onclick="toggle()">
                    Less
                </button>
            </div>
        </div>
        <div id="notes">
            @if (notas.Count > 1)
            {
                @*Hay que evitar poner las notas que se corresponden con los ejemplos o con cosas que no queremos tener en cuenta(id = grupos 0,1,2,7,9)*@
                @foreach (Nota nota in notas.Where(notaAux => notaAux.IdNota >= 1000 && notaAux.IdNota <= 7999))
                {
                    int notaIndex = notas.IndexOf(nota);
                    <div uk-grid>
                        <div class="uk-width-auto">
                            <input class="uk-checkbox" type="checkbox" name="@nota.IdNota" @onchange="e => ManageListOfNotes(notaIndex)" checked="@selectedNotas.Contains(nota.IdNota)" />
                        </div>
                        <div class="uk-width-expand">
                            @if ((nota.IdNota >= 1000 && nota.IdNota <= 4999) || (nota.IdNota >= 6000 && nota.IdNota <= 7999))
                            {
                                <span @onclick="e => GetVerbosConNota(nota.IdNota, nota.Descripcion)" style="cursor:pointer;">@((MarkupString)(nota.Descripcion))</span>
                            }
                            else
                            {
                                <span >@((MarkupString)(nota.Descripcion))</span>

                            }
                        </div>
                    </div>
                    @*<label>
                            <input class="uk-checkbox" type="checkbox" name="@nota.IdNota" @onchange="e => ManageListOfNotes(notaIndex)" checked="@selectedNotas.Contains(nota.IdNota)" /> <span @onclick="e => GetVerbosConNota(nota.IdNota)">@((MarkupString)(nota.Descripcion))</span>
                        </label>*@
                }
                <TablaResultados listOfResults="resultadosNota" titleOfNote="@tituloDeLaNota"></TablaResultados>
                //fuentes
                @foreach (Nota nota in notas.Where(notaAux => notaAux.IdNota >= 9001 && notaAux.IdNota <= 9018))
                {
                    <label>
                        <span>@((MarkupString)(nota.Descripcion))</span>
                    </label>
                }
            }
            else
            {

                <h5 class="uk-text-meta uk-text-center">@_localizer.WithCulture(state.getCurrentCulture())["no_notas"].Value</h5>
            }
        </div>
    </div>
    <TablaModos indicativo="modoIndicativo" subjuntivo="modoSubjuntivo" imperativo="modoImperativo" formasImpersonales="formasImpersonales" notasSeleccionadas="selectedNotas" noTieneCodigo="noTieneCodigo"></TablaModos>
    <Conjugaciones conjugaciones="conjugaciones"></Conjugaciones>
}
else
{
    <header>
        @if (!esVerbo)
        {
            <h3 class="uk-text-center">@_localizer.WithCulture(state.getCurrentCulture())["no_verbo"].Value</h3>
            <div>
                <h5>@_localizer.WithCulture(state.getCurrentCulture())["sugerencias"].Value @(string.Join(", ", sugerencias.ToArray()))</h5>
                <h5>@_localizer.WithCulture(state.getCurrentCulture())["similares"].Value @(string.Join(", ", similares.ToArray()))</h5>
            </div>
        }
        else
        {
            <h3 class="uk-text-center">@_localizer.WithCulture(state.getCurrentCulture())["empezar"].Value</h3>

        }
    </header>
}

@code{

    [Parameter] public string searchText { get; set; }

    private LematizadorService _lematizador { get; set; }
    private ConjugadorService _conjugador { get; set; }
    private CorrectorService _corrector { get; set; }
    private List<Reconocimiento> reconocimientos { get; set; }
    private List<InfoConjugacion> conjugaciones { get; set; }
    private InfoCanonica info { get; set; }

    private List<Nota> notas { get; set; }
    private List<int> selectedNotas { get; set; }

    private string[] formasImpersonales { get; set; }

    private ModoVerbo modoIndicativo { get; set; }
    private ModoVerbo modoImperativo { get; set; }
    private ModoVerbo modoSubjuntivo { get; set; }
    private bool noTieneCodigo { get; set; } = true;
    private int _selectedIndex { get; set; }

    private bool esVerbo { get; set; } = true;

    private List<string> sugerencias { get; set; }
    private List<string> similares { get; set; }

    //Para el buscador de las notas
    private List<string> resultadosNota { get; set; }
    private string tituloDeLaNota { get; set;}

    public string[] reconocimientoHeaders =
    {
            "Forma canónica",
            "Frecuencia",
            "Código de flexión",
            "Código de forma canónica",
            "Prefijos",
            "Pronombres"
        };

    public string[] canonicaHeaders =
    {
            "AntiguaField",
            "DRAEXXIIIField",
            "FormaCanonicaField",
            "FrecuenciaField",
            "IdCategoriaField",
            "IdCategoriaGNField",
            "IdFlexionField",
            "MaxAcepcionesField",
            "MaxEtimologiaField",
            "NumAcepcionField",
            "NumAcepcionSecField",
            "NumEtimologiaField",
            "PosAcepcionField",
            "PosAcepcionSecField"
        };

}
@functions{

    protected override void OnInitialized()
    {
        reconocimientos = new List<Reconocimiento>();
        similares = new List<string>();
        sugerencias = new List<string>();
        info = new InfoCanonica();
        _lematizador = new LematizadorService();
        _conjugador = new ConjugadorService();
        _corrector = new CorrectorService();
        _selectedIndex = 0;
        selectedNotas = new List<int>();
        notas = new List<Nota>();
        resultadosNota = new List<string>();
        tituloDeLaNota = "";
        state.OnChange += OnCultureChange;
    }

    public void Dispose()
    {
        state.OnChange -= OnCultureChange;
    }

    private void OnCultureChange()
    {
        StateHasChanged();
    }

    public async void SearchVerb(string verb)
    {
        if (verb == "") return;

        searchText = verb;
        selectedNotas.Clear();
        notas.Clear();
        noTieneCodigo = true;
        _selectedIndex = 0;
        reconocimientos = await _lematizador.GetReconocimientosAsync(verb);
        if (reconocimientos.Count > 0)
        {
            GetDataFromSelectedIndex(_selectedIndex);
        }
        else
        {
            //No es un verbo o no está bien escrito
            esVerbo = false;
            similares = await _corrector.GetSimilaresAsync(verb);
            sugerencias = await _corrector.GetSugerenciasAsync(verb);
            StateHasChanged();
        }
    }

    public async void GetDataFromSelectedIndex(int index)
    {
        _selectedIndex = index;

        //La manera de hacerlo todo en paralelo para reducir tiempos de espera fue sacada del siguiente enlace
        //https://stackoverflow.com/questions/17197699/awaiting-multiple-tasks-with-different-results
        Task<List<InfoConjugacion>> taskConjugaciones = _conjugador.GetInfoConjugacion(reconocimientos[_selectedIndex].IdFormaCanonica);
        Task<InfoCanonica> taskCanonica = _lematizador.GetInfoCanonicaAsync(reconocimientos[_selectedIndex].IdFormaCanonica);
        Task<List<string>> taskDefiniciones = _conjugador.GetDefinicionesAsync(reconocimientos[_selectedIndex].IdFormaCanonica);

        await Task.WhenAll(taskConjugaciones, taskCanonica, taskDefiniciones);

        conjugaciones = await taskConjugaciones;
        info = await taskCanonica;
        List<string> definiciones = await taskDefiniciones;
        //---

        if (conjugaciones != null)
        {
            formasImpersonales = new String[3];
            formasImpersonales[0] = conjugaciones[0].Forma; //inf
            formasImpersonales[1] = conjugaciones[1].Forma; //par
            formasImpersonales[2] = conjugaciones[2].Forma; //ger
            modoIndicativo = FormatearConjugaciones(conjugaciones.Where(conjugacion => conjugacion.IdFlexion >= 10 && conjugacion.IdFlexion <= 57).ToList(), "Indicativo");
            modoSubjuntivo = FormatearConjugaciones(conjugaciones.Where(conjugacion => conjugacion.IdFlexion >= 60 && conjugacion.IdFlexion <= 87).ToList(), "Subjuntivo");
            modoImperativo = FormatearConjugaciones(conjugaciones.Where(conjugacion => conjugacion.IdFlexion >= 90 && conjugacion.IdFlexion <= 98).ToList(), "Imperativo");
            InfoConjugacion infinitivo = conjugaciones.Where(conjugacion => conjugacion.IdFlexion == 1).First();
            bool aux = conjugaciones.Any(conj => conj.IdCategorias.Contains(3002));
            noTieneCodigo = !aux;
            notas = infinitivo.Notas;
        }

        StateHasChanged();
    }

    private ModoVerbo FormatearConjugaciones(List<InfoConjugacion> conjugacionesDelModo, string modo = "imperativo")
    {
        List<ConjugacionVerbo> listaConjugaciones = new List<ConjugacionVerbo>();
        switch (modo)
        {
            case "Indicativo":
                //Presente
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Presente", "Presente" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 10 && conjugacion.IdFlexion <= 18).ToList(),
                        new int[] { 10, 15 },
                        new int[] { 16, 17 },
                        18
                    )
                );
                //Preterito imperfecto o copreterito
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Preterito_imperfecto", "Copreterito" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 20 && conjugacion.IdFlexion <= 27).ToList(),
                        new int[] { 20, 25 },
                        new int[] { 26, 27 }
                    )
                );
                //Pretérito perfecto simple o pretérito
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Preterito_perfecto_simple", "Preterito" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 30 && conjugacion.IdFlexion <= 37).ToList(),
                        new int[] { 30, 35 },
                        new int[] { 36, 37 }
                    )
                );
                //Futuro simple
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Futuro_simple", "Futuro" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 40 && conjugacion.IdFlexion <= 47).ToList(),
                        new int[] { 40, 45 },
                        new int[] { 46, 47 }
                    )
                );
                //Condicional simple
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Condicional_simple", "Pospreterito" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 50 && conjugacion.IdFlexion <= 57).ToList(),
                        new int[] { 50, 55 },
                        new int[] { 56, 57 }
                    )
                );
                break;
            case "Subjuntivo":
                //Presente subjuntivo
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Presente", "Presente" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 60 && conjugacion.IdFlexion <= 67).ToList(),
                        new int[] { 60, 65 },
                        new int[] { 66, 67 }
                    )
                );
                //Pretérito imperfecto subjuntivo
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Preterito_imperfecto", "Preterito" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 70 && conjugacion.IdFlexion <= 77).ToList(),
                        new int[] { 70, 75 },
                        new int[] { 76, 77 }
                    )
                );
                //Futuro subjuntivo
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Futuro", "Futuro_simple" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 80 && conjugacion.IdFlexion <= 87).ToList(),
                        new int[] { 80, 85 },
                        new int[] { 86, 87 }
                    )
                );
                break;
            default:
                //Imperativo
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Imperativo", "Imperativo" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 91 && conjugacion.IdFlexion <= 98).ToList(),
                        new int[] { 90, 95 },
                        new int[] { 96, 97 },
                        98,
                        true
                    )
                );
                break;
        }

        ModoVerbo result = new ModoVerbo(modo, listaConjugaciones);
        return result;
    }

    private ConjugacionVerbo GetConjugacionFromInfoConjugacion_2
            (
                string[] nombreConjugacion,
                List<InfoConjugacion> infoConjugaciones,
                int[] espIndex,
                int[] canIndex,
                int indexVos = -1,
                bool incompleto = false
            )
    {
        ConjugacionVerbo conjugacion = new ConjugacionVerbo();

        conjugacion.nombreConjugacion = nombreConjugacion;
        infoConjugaciones.Sort((info1, info2) => info1.IdFlexion.CompareTo(info2.IdFlexion));

        conjugacion.conjEsp = new List<List<InfoConjugacion>>();
        conjugacion.conjCan = new List<List<InfoConjugacion>>();
        conjugacion.conjFor = new List<List<InfoConjugacion>>();
        conjugacion.conjVos = new List<List<InfoConjugacion>>();

        for (int i = espIndex[0]; i <= espIndex[1]; i++)
        {
            conjugacion.conjEsp.Add(infoConjugaciones.Where(info => info.IdFlexion == i).ToList());
            conjugacion.conjCan.Add(infoConjugaciones.Where(info => info.IdFlexion == i).ToList());
            conjugacion.conjFor.Add(infoConjugaciones.Where(info => info.IdFlexion == i).ToList());
            conjugacion.conjVos.Add(infoConjugaciones.Where(info => info.IdFlexion == i).ToList());
        }

        //modificacion del voseo (la segunda persona del singular => posicion 1; y la segunda persona del plural => posicion 2)
        if (indexVos != -1)
            conjugacion.conjVos[1] = infoConjugaciones.Where(info => info.IdFlexion == indexVos).ToList();
        conjugacion.conjVos[4] = infoConjugaciones.Where(info => info.IdFlexion == espIndex[1]).ToList();

        //modificacion del canario (la segunda persona del plural => posicion 4)
        conjugacion.conjCan[4] = infoConjugaciones.Where(info => info.IdFlexion == canIndex[1]).ToList();

        //modificacion del formal (la segunda persona del singular => posicion 1; y la segunda persona del plural => posicion 4)
        conjugacion.conjFor[1] = infoConjugaciones.Where(info => info.IdFlexion == canIndex[0]).ToList();
        conjugacion.conjFor[4] = infoConjugaciones.Where(info => info.IdFlexion == canIndex[1]).ToList();

        return conjugacion;
    }
    private void ManageListOfNotes(int indexOfNotes)
    {
        int idNota = notas[indexOfNotes].IdNota;
        if (selectedNotas.Contains(idNota))
        {
            selectedNotas.Remove(idNota);
        }
        else
        {
            selectedNotas.Add(idNota);
        }
    }

    private async void GetVerbosConNota(int idNota, string tituloNota)
    {
        List<string> res = await _conjugador.GetVerbosConNotaAsync(idNota);
        if (resultadosNota.Count == res.Count && resultadosNota.All(resultado => res.Contains(resultado)))
        {
            tituloDeLaNota = "";
            resultadosNota.Clear();
        }
        else
        {
            tituloDeLaNota = tituloNota;
            resultadosNota = res;
        }
        StateHasChanged();
    }
}