@page "/TableReconocimientos"
@page "/TableReconocimientos/{verb}"

@using Services
@using ConexionConjugador
@using ConexionCorrector
@using ConexionLematizador
@using Data
@using Microsoft.AspNetCore.Html
@using System.Globalization
@using System.Collections.Concurrent 
@inject IStringLocalizer<TablaReconocimientos> _localizer
@inject AppState state

@implements IDisposable

<TablaCanonica infos="infoArr"></TablaCanonica>

@if (reconocimientos.Count > 0)
{
    <header id="verb_name">
        <h1 class="uk-text-center">
            @((MarkupString)string.Format(_localizer.WithCulture(state.getCurrentCulture())["conjugacion_verbo"].Value, reconocimientos[_selectedIndex].FormaCanonica))
        </h1>
        @if (notas.Count > 0)
        {
            <p class="uk-text-meta uk-text-center" style="cursor: pointer;" id="same_conjugation" @onclick="e => GetVerbosMismaconjugacion(notas.First(nota => nota.IdNota >= 7002 && nota.IdNota <= 7173).IdNota, notas.First(nota => nota.IdNota >= 7002 && nota.IdNota <= 7173).Descripcion)">
                @((MarkupString)notas.First(nota => nota.IdNota >= 7002 && nota.IdNota <= 7173).Descripcion)
            </p>
        }
    </header>
    <hr />
    <TablaResultados listOfResults="resultadosConjugacion" titleOfNote="@tituloConjugacion"></TablaResultados>

    <div id="results" class="uk-child-width-expand uk-grid-column-medium" uk-grid>
        @foreach (Reconocimiento reconocimiento in reconocimientos)
        {
            int index = reconocimientos.IndexOf(reconocimiento);
            <div id="@index" class="uk-card uk-card-small uk-card-default @((_selectedIndex == index) ? "selected" : "")"
                 @onclick="e => GetDataFromSelectedIndex(index)">
                <p class="uk-text-center">
                    @string.Format(_localizer.WithCulture(state.getCurrentCulture())["verbo_seleccion"], searchText, reconocimiento.FormaCanonica)
                </p>
            </div>
        }
    </div>
    <table class="uk-table">
        <thead>
            <tr>
                @foreach (string header in reconocimientoHeaders)
                {
                    <th>@header</th>
                }
            </tr>
        </thead>
        <tbody>
            @foreach (Reconocimiento reconocimiento in reconocimientos)
            {
                <tr>
                    <td>@reconocimiento.FormaCanonica.</td>
                    <td>@reconocimiento.Frecuencia</td>
                    <td>@reconocimiento.IdFlexion</td>
                    <td>@reconocimiento.IdFormaCanonica</td>
                    <td>@reconocimiento.Prefijos</td>
                    <td>@reconocimiento.Pronombres</td>
                </tr>
            }
        </tbody>
    </table>
    <hr />
    <div class="uk-margin uk-card uk-card-default uk-card-body notes">
        <div class="uk-flex uk-flex-between card-heading">
            <h3 class="uk-card-title">
                @_localizer["notas"].Value
            </h3>
            <div>
                <button class="uk-button uk-button-text close-btn"
                        uk-toggle="target: #notes; animation: uk-animation-fade"
                        type="button"
                        onclick="toggle()">
                    Less
                </button>
            </div>
        </div>
        <div id="notes">
            @if (notas.Count > 1)
            {
                @foreach (Nota nota in notas.Where(notaAux => notaAux.IdNota >= 1000 && notaAux.IdNota <= 7999))
                {
                    if (nota.IdNota < 7002 || nota.IdNota > 7173)
                    {
                        <TablaConNota conjugador="_conjugador"
                                      HasCheckbox="conjugaciones.Any(conjugacion => (conjugacion.IdNotas != null && conjugacion.IdNotas.Contains(nota.IdNota)) && (conjugacion.IdFlexion != 1))"
                                      IsSelected="selectedNotas.Contains(nota.IdNota)"
                                      nota="nota"
                                      OnCheckboxChange="ManageListOfNotesWithNoteId">
                        </TablaConNota>
                    }
                }
                //fuentes
                @foreach (Nota nota in notas.Where(notaAux => notaAux.IdNota >= 9001 && notaAux.IdNota <= 9018))
                {
                    <label style="margin-top:1.25rem;">
                        <span>@((MarkupString)(nota.Descripcion))</span>
                    </label>
                }
            }
            else
            {
                <h5 class="uk-text-meta uk-text-center">@_localizer.WithCulture(state.getCurrentCulture())["no_notas"].Value</h5>
            }
        </div>
    </div>
    <TablaModos indicativo="modoIndicativo" subjuntivo="modoSubjuntivo" imperativo="modoImperativo" formasImpersonales="formasImpersonales" notasSeleccionadas="selectedNotas" noTieneCodigo="noTieneCodigo"></TablaModos>
    @*<Conjugaciones conjugaciones="conjugaciones"></Conjugaciones>*@
}
else
{
    <header>
        @if (!esVerbo)
        {
            <h3 class="uk-text-center">@_localizer.WithCulture(state.getCurrentCulture())["no_verbo"].Value</h3>
            <div>
                <h5>@_localizer.WithCulture(state.getCurrentCulture())["sugerencias"].Value @(string.Join(", ", sugerencias.ToArray()))</h5>
                <h5>@_localizer.WithCulture(state.getCurrentCulture())["similares"].Value @(string.Join(", ", similares.ToArray()))</h5>
            </div>
        }
        else
        {
            <h3 class="uk-text-center">@_localizer.WithCulture(state.getCurrentCulture())["empezar"].Value</h3>

        }
    </header>
}

@code{

    [Parameter] public string searchText { get; set; }

    private LematizadorService _lematizador { get; set; }
    private ConjugadorService _conjugador { get; set; }
    private CorrectorService _corrector { get; set; }
    private List<Reconocimiento> reconocimientos { get; set; }
    private List<InfoConjugacion> conjugaciones { get; set; }
    private ConcurrentSet<InfoCanonica> infoArr { get; set; } = new ConcurrentSet<InfoCanonica>(new InfoCanonicaComparer());

    private List<Nota> notas { get; set; }
    private List<int> selectedNotas { get; set; }

    private string[] formasImpersonales { get; set; }

    private ModoVerbo modoIndicativo { get; set; }
    private ModoVerbo modoImperativo { get; set; }
    private ModoVerbo modoSubjuntivo { get; set; }
    private bool noTieneCodigo { get; set; } = true;
    private int _selectedIndex { get; set; }

    private bool esVerbo { get; set; } = true;

    private List<string> sugerencias { get; set; }
    private List<string> similares { get; set; }

    //Para el buscador de las notas
    private List<string> resultadosNota { get; set; }
    private string tituloDeLaNota { get; set; }

    //Para la lista con la misma conjugacion
    private List<string> resultadosConjugacion { get; set; }
    private string tituloConjugacion { get; set; }

    public string[] reconocimientoHeaders =
    {
            "Forma canónica",
            "Frecuencia",
            "Código de flexión",
            "Código de forma canónica",
            "Prefijos",
            "Pronombres"
        };



}
@functions{

    protected override void OnInitialized()
    {
        reconocimientos = new List<Reconocimiento>();
        similares = new List<string>();
        sugerencias = new List<string>();
        _lematizador = new LematizadorService();
        _conjugador = new ConjugadorService();
        _corrector = new CorrectorService();
        _selectedIndex = 0;
        selectedNotas = new List<int>();
        notas = new List<Nota>();
        resultadosNota = new List<string>();
        tituloDeLaNota = "";
        resultadosConjugacion = new List<string>();
        tituloConjugacion = "";
        state.OnChange += OnCultureChange;
    }

    public void Dispose()
    {
        state.OnChange -= OnCultureChange;
    }

    private void OnCultureChange()
    {
        StateHasChanged();
    }

    public async Task SearchVerb(string verb)
    {
        if (verb == "" || verb == null) return;

        searchText = verb;
        selectedNotas.Clear();
        notas.Clear();
        noTieneCodigo = true;
        _selectedIndex = 0;
        reconocimientos = await _lematizador.GetReconocimientosAsync(verb);
        if (reconocimientos.Count > 0)
        {
            //Hacer las llamadas en paralelo para un array lo encontré en este enlace
            //https://stackoverflow.com/questions/15136542/parallel-foreach-with-asynchronous-lambda
            infoArr.Clear();
            var tasks = reconocimientos.Select(async reconocimiento =>
            {
                var infoCanonicaOfReconocimiento = await _lematizador.GetInfoCanonicaAsync(reconocimiento.IdFormaCanonica);
                infoArr.Add(infoCanonicaOfReconocimiento);
            });
            var count = reconocimientos.Count;
            var count_2 = tasks.Count();
            await Task.WhenAll(tasks);
            await GetDataFromSelectedIndex(_selectedIndex);
        }
        else
        {
            //No es un verbo o no está bien escrito
            esVerbo = false;
            similares = await _corrector.GetSimilaresAsync(verb);
            sugerencias = await _corrector.GetSugerenciasAsync(verb);
        }
        StateHasChanged();
    }

    public async Task GetDataFromSelectedIndex(int index)
    {
        _selectedIndex = index;
        selectedNotas.Clear();
        notas.Clear();
        noTieneCodigo = true;
        //La manera de hacerlo todo en paralelo para reducir tiempos de espera fue sacada del siguiente enlace
        //https://stackoverflow.com/questions/17197699/awaiting-multiple-tasks-with-different-results
        Task<List<InfoConjugacion>> taskConjugaciones = _conjugador.GetInfoConjugacion(reconocimientos[_selectedIndex].IdFormaCanonica);
        Task<List<string>> taskDefiniciones = _conjugador.GetDefinicionesAsync(reconocimientos[_selectedIndex].IdFormaCanonica);

        await Task.WhenAll(taskConjugaciones, taskDefiniciones);

        conjugaciones = await taskConjugaciones;
        List<string> definiciones = await taskDefiniciones;
        //---
        if (conjugaciones != null)
        {
            formasImpersonales = new String[3];
            formasImpersonales[0] = conjugaciones[0].Forma; //inf
            formasImpersonales[1] = conjugaciones[1].Forma; //par
            formasImpersonales[2] = conjugaciones[2].Forma; //ger
            modoIndicativo = FormatearConjugaciones(conjugaciones.Where(conjugacion => conjugacion.IdFlexion >= 10 && conjugacion.IdFlexion <= 57).ToList(), "Indicativo");
            modoSubjuntivo = FormatearConjugaciones(conjugaciones.Where(conjugacion => conjugacion.IdFlexion >= 60 && conjugacion.IdFlexion <= 87).ToList(), "Subjuntivo");
            modoImperativo = FormatearConjugaciones(conjugaciones.Where(conjugacion => conjugacion.IdFlexion >= 90 && conjugacion.IdFlexion <= 98).ToList(), "Imperativo");
            InfoConjugacion infinitivo = conjugaciones.Where(conjugacion => conjugacion.IdFlexion == 1).First();
            bool aux = conjugaciones.Any(conj => conj.IdCategorias.Contains(3002));
            noTieneCodigo = !aux;
            notas = infinitivo.Notas;
        }

        StateHasChanged();
    }

    private ModoVerbo FormatearConjugaciones(List<InfoConjugacion> conjugacionesDelModo, string modo = "imperativo")
    {
        List<ConjugacionVerbo> listaConjugaciones = new List<ConjugacionVerbo>();
        switch (modo)
        {
            case "Indicativo":
                //Presente
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Presente", "Presente" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 10 && conjugacion.IdFlexion <= 18).ToList(),
                        new int[] { 10, 15 },
                        new int[] { 16, 17 },
                        18
                    )
                );
                //Preterito imperfecto o copreterito
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Preterito_imperfecto", "Copreterito" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 20 && conjugacion.IdFlexion <= 27).ToList(),
                        new int[] { 20, 25 },
                        new int[] { 26, 27 }
                    )
                );
                //Pretérito perfecto simple o pretérito
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Preterito_perfecto_simple", "Preterito" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 30 && conjugacion.IdFlexion <= 37).ToList(),
                        new int[] { 30, 35 },
                        new int[] { 36, 37 }
                    )
                );
                //Futuro simple
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Futuro_simple", "Futuro" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 40 && conjugacion.IdFlexion <= 47).ToList(),
                        new int[] { 40, 45 },
                        new int[] { 46, 47 }
                    )
                );
                //Condicional simple
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Condicional_simple", "Pospreterito" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 50 && conjugacion.IdFlexion <= 57).ToList(),
                        new int[] { 50, 55 },
                        new int[] { 56, 57 }
                    )
                );
                break;
            case "Subjuntivo":
                //Presente subjuntivo
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Presente", "Presente" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 60 && conjugacion.IdFlexion <= 67).ToList(),
                        new int[] { 60, 65 },
                        new int[] { 66, 67 }
                    )
                );
                //Pretérito imperfecto subjuntivo
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Preterito_imperfecto", "Preterito" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 70 && conjugacion.IdFlexion <= 77).ToList(),
                        new int[] { 70, 75 },
                        new int[] { 76, 77 }
                    )
                );
                //Futuro subjuntivo
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Futuro", "Futuro_simple" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 80 && conjugacion.IdFlexion <= 87).ToList(),
                        new int[] { 80, 85 },
                        new int[] { 86, 87 }
                    )
                );
                break;
            default:
                //Imperativo
                listaConjugaciones.Add(
                    GetConjugacionFromInfoConjugacion_2(
                        new string[] { "Imperativo", "Imperativo" },
                        conjugacionesDelModo.Where(conjugacion => conjugacion.IdFlexion >= 91 && conjugacion.IdFlexion <= 98).ToList(),
                        new int[] { 90, 95 },
                        new int[] { 96, 97 },
                        98,
                        true
                    )
                );
                break;
        }

        ModoVerbo result = new ModoVerbo(modo, listaConjugaciones);
        return result;
    }

    private ConjugacionVerbo GetConjugacionFromInfoConjugacion_2
            (
                string[] nombreConjugacion,
                List<InfoConjugacion> infoConjugaciones,
                int[] espIndex,
                int[] canIndex,
                int indexVos = -1,
                bool incompleto = false
            )
    {
        ConjugacionVerbo conjugacion = new ConjugacionVerbo();

        conjugacion.nombreConjugacion = nombreConjugacion;
        infoConjugaciones.Sort((info1, info2) => info1.IdFlexion.CompareTo(info2.IdFlexion));

        conjugacion.conjEsp = new List<List<InfoConjugacion>>();
        conjugacion.conjCan = new List<List<InfoConjugacion>>();
        conjugacion.conjFor = new List<List<InfoConjugacion>>();
        conjugacion.conjVos = new List<List<InfoConjugacion>>();

        for (int i = espIndex[0]; i <= espIndex[1]; i++)
        {
            conjugacion.conjEsp.Add(infoConjugaciones.Where(info => info.IdFlexion == i).ToList());
            conjugacion.conjCan.Add(infoConjugaciones.Where(info => info.IdFlexion == i).ToList());
            conjugacion.conjFor.Add(infoConjugaciones.Where(info => info.IdFlexion == i).ToList());
            conjugacion.conjVos.Add(infoConjugaciones.Where(info => info.IdFlexion == i).ToList());
        }

        //modificacion del voseo (la segunda persona del singular => posicion 1; y la segunda persona del plural => posicion 2)
        if (indexVos != -1)
            conjugacion.conjVos[1] = infoConjugaciones.Where(info => info.IdFlexion == indexVos).ToList();
        conjugacion.conjVos[4] = infoConjugaciones.Where(info => info.IdFlexion == espIndex[1]).ToList();

        //modificacion del canario (la segunda persona del plural => posicion 4)
        conjugacion.conjCan[4] = infoConjugaciones.Where(info => info.IdFlexion == canIndex[1]).ToList();

        //modificacion del formal (la segunda persona del singular => posicion 1; y la segunda persona del plural => posicion 4)
        conjugacion.conjFor[1] = infoConjugaciones.Where(info => info.IdFlexion == canIndex[0]).ToList();
        conjugacion.conjFor[4] = infoConjugaciones.Where(info => info.IdFlexion == canIndex[1]).ToList();

        return conjugacion;
    }

    private void ManageListOfNotesWithNoteId(int noteId)
    {
        if (selectedNotas.Contains(noteId))
        {
            selectedNotas.Remove(noteId);
        }
        else
        {
            selectedNotas.Add(noteId);
        }
        StateHasChanged();
    }

    private async void GetVerbosMismaconjugacion(int conjugacion, string titulo)
    {
        List<string> res = await _conjugador.GetVerbosConNotaAsync(conjugacion);
        if (resultadosConjugacion.Count == res.Count && resultadosConjugacion.All(resultado => res.Contains(resultado)))
        {
            tituloDeLaNota = "";
            resultadosConjugacion.Clear();
        }
        else
        {
            tituloConjugacion = titulo;
            resultadosConjugacion = res;
        }
        StateHasChanged();
    }

    private bool HasToHaveCheckbox(int nota)
    {
        return false;
    }
}